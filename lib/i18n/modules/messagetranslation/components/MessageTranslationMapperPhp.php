<?php
/**
 * MessageTranslationMapperPhp class file.
 *
 * @author Paul Klimov <pklimov@quartsoft.com>
 * @link http://www.quartsoft.com/
 * @copyright Copyright &copy; 2010-2013 QuartSoft ltd.
 * @license http://www.quartsoft.com/license/
 */

/**
 * MessageTranslationMapperPhp is a message translation model mapper, which uses the
 * php code files to store translations.
 * This mapper works with the {@link CPhpMessageSource} message source.
 *
 * @see MessageTranslation
 * @see CPhpMessageSource
 *
 * @property string $basePath public alias of {@link _basePath}.
 * @property integer $filePermission public alias of {@link _filePermission}.
 *
 * @author Paul Klimov <pklimov@quartsoft.com>
 * @package qs.i18n.modules.messagetranslation
 */
class MessageTranslationMapperPhp extends MessageTranslationMapper {
	/**
	 * @var string the base path for all translated messages.
	 */
	protected $_basePath = '';
	/**
	 * @var integer the chmod permission for directories and files,
	 * created in the process. Defaults to 0755 (owner rwx, group rx and others rx).
	 */
	protected $_filePermission = 0755;

	// Set / Get :
	
	public function setBasePath($basePath) {
		$this->_basePath = $basePath;
		return true;
	}

	public function getBasePath() {
		if (empty($this->_basePath)) {
			$this->initBasePath();
		}
		return $this->_basePath;
	}

	public function setFilePermission($filePermission) {
		$this->_filePermission = $filePermission;
		return true;
	}

	public function getFilePermission() {
		return $this->_filePermission;
	}

	/**
	 * Initializes {@link basePath} value.
	 * @return boolean success.
	 */
	protected function initBasePath() {
		$basePath = '';

		$messageSource = Yii::app()->getMessages();
		if (is_a($messageSource, 'CPhpMessageSource')) {
			$basePath = $messageSource->basePath;
		}
		if (empty($defaultMessagePath)) {
			$basePath = Yii::getPathOfAlias('application.messages');
		}

		$this->_basePath = $basePath;
		return true;
	}

	/**
	 * Finds existing message translations.
	 * While results filtering is performed separately,
	 * passed search filter can be used to filter translation list at this
	 * stage to save performance.
	 * @param MessageTranslationFilter $filter search filter.
	 * @return array list of translation data, each translation data is an array
	 * with following keys: 'name', 'category', 'language', 'content'.
	 */
	protected function findTranslations(MessageTranslationFilter $filter) {
		$basePath = $this->getBasePath();

		$fileSearchOptions = array(
			'fileTypes' => array(
				'php',
			),
			'exclude'=>array(
				'config.php'
			),
		);
		$translationFiles = CFileHelper::findFiles($basePath, $fileSearchOptions);

		$translations = array();

		foreach ($translationFiles as $translationFile) {
			$categoryName = basename($translationFile, '.php');
			// Apply filter to save performance:
			if (!empty($filter->category_name)) {
				if (strpos($categoryName, $filter->category_name) === false) {
					continue;
				}
			}
			$language = basename( dirname($translationFile) );
			$messages = require($translationFile);
			foreach ($messages as $messageName => $messageContent) {
				$translations[] = array(
					'name' => $messageName,
					'category' => $categoryName,
					'language' => $language,
					'content' => $messageContent,
				);
			}
		}

		return $translations;
	}

	/**
	 * Saves the particular message translation content on particular language.
	 * @param string $category message category name.
	 * @param string $name message self name.
	 * @param string $language language locale code.
	 * @param string $content message content on specified language.
	 * @return boolean success.
	 */
	protected function saveTranslation($category, $name, $language, $content) {
		$translationFileName = $this->getBasePath() . DIRECTORY_SEPARATOR . $language . DIRECTORY_SEPARATOR . $category . '.php';
		if (file_exists($translationFileName)) {
			$translations = require($translationFileName);
		} else {
			$translations = array();
		}
		$translations[$name] = $content;
		return $this->saveTranslationFile($translationFileName, $translations);
	}

	/**
	 * Saves the message translations into the PHP file.
	 * @param string $fileName full translation file name.
	 * @param array $translations set of message translations.
	 * @return boolean success.
	 */
	protected function saveTranslationFile($fileName, array $translations) {
		$this->resolvePath(dirname($fileName));
		if (file_exists($fileName)) {
			unlink($fileName);
		}

		ksort($translations);
		$arrayString = str_replace("\r", '', var_export($translations, true));

		$generatorName = get_class($this);

		$content=<<<EOD
<?php
/**
 * Message translations.
 *
 * This file is automatically generated by '$generatorName'.
 * It contains the localizable messages extracted from source code.
 * You may modify this file by translating the extracted messages.
 *
 * Each array element represents the translation (value) of a message (key).
 * If the value is empty, the message is considered as not translated.
 *
 * Message string can be used with plural forms format. Check i18n section
 * of the guide for details.
 *
 * NOTE, this file must be saved in UTF-8 encoding.
 *
 * @version \$Id: \$
 */
return $arrayString;

EOD;
		$bytesWritten = file_put_contents($fileName, $content);
		return ($bytesWritten > 0);
	}

	/**
	 * Makes sure given file path exists and writeable.
	 * Attempts to create missing path.
	 * @throws CException on failure.
	 * @param string $path file path.
	 * @return string file path.
	 */
	protected function resolvePath($path) {
		if (!file_exists($path)) {
			$oldUmask = umask(0);
			$dirPermission = $this->getFilePermission();
			@mkdir($path, $dirPermission, true);
			umask($oldUmask);
		}
		if (!file_exists($path) || !is_dir($path)) {
			throw new CException("Unable to resolve path: '{$path}'!");
		} elseif (!is_writable($path)) {
			throw new CException("Path: '{$path}' should be writeable!");
		}
		return $path;
	}
}
